// src/receiver.ts
import * as jose from "jose";
import crypto from "crypto-js";
var SignatureError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "SignatureError";
  }
};
var Receiver = class {
  currentSigningKey;
  nextSigningKey;
  constructor(config) {
    this.currentSigningKey = config.currentSigningKey;
    this.nextSigningKey = config.nextSigningKey;
  }
  /**
   * Verify the signature of a request.
   *
   * Tries to verify the signature with the current signing key.
   * If that fails, maybe because you have rotated the keys recently, it will
   * try to verify the signature with the next signing key.
   *
   * If that fails, the signature is invalid and a `SignatureError` is thrown.
   */
  async verify(request) {
    const isValid = await this.verifyWithKey(this.currentSigningKey, request);
    if (isValid) {
      return true;
    }
    return this.verifyWithKey(this.nextSigningKey, request);
  }
  /**
   * Verify signature with a specific signing key
   */
  async verifyWithKey(key, request) {
    const jwt = await jose.jwtVerify(request.signature, new TextEncoder().encode(key), {
      issuer: "Upstash",
      clockTolerance: request.clockTolerance
    }).catch((error) => {
      throw new SignatureError(error.message);
    });
    const p = jwt.payload;
    if (request.url !== void 0 && p.sub !== request.url) {
      throw new SignatureError(`invalid subject: ${p.sub}, want: ${request.url}`);
    }
    const bodyHash = crypto.SHA256(request.body).toString(crypto.enc.Base64url);
    const padding = new RegExp(/=+$/);
    if (p.body.replace(padding, "") !== bodyHash.replace(padding, "")) {
      throw new SignatureError(`body hash does not match, want: ${p.body}, got: ${bodyHash}`);
    }
    return true;
  }
};

export {
  SignatureError,
  Receiver
};
