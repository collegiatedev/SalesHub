"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

var _chunkUUR7N6E6js = require('./chunk-UUR7N6E6.js');

// src/nextjs.ts
var _server = require('next/server');
var BAD_REQUEST = 400;
function verifySignature(handler, config) {
  const currentSigningKey = _nullishCoalesce(_optionalChain([config, 'optionalAccess', _ => _.currentSigningKey]), () => ( process.env.QSTASH_CURRENT_SIGNING_KEY));
  if (!currentSigningKey) {
    throw new Error(
      "currentSigningKey is required, either in the config or as env variable QSTASH_CURRENT_SIGNING_KEY"
    );
  }
  const nextSigningKey = _nullishCoalesce(_optionalChain([config, 'optionalAccess', _2 => _2.nextSigningKey]), () => ( process.env.QSTASH_NEXT_SIGNING_KEY));
  if (!nextSigningKey) {
    throw new Error(
      "nextSigningKey is required, either in the config or as env variable QSTASH_NEXT_SIGNING_KEY"
    );
  }
  const receiver = new (0, _chunkUUR7N6E6js.Receiver)({
    currentSigningKey,
    nextSigningKey
  });
  return async (request, response) => {
    const signature = request.headers["upstash-signature"];
    if (!signature) {
      response.status(BAD_REQUEST);
      response.send("`Upstash-Signature` header is missing");
      response.end();
      return;
    }
    if (typeof signature !== "string") {
      throw new TypeError("`Upstash-Signature` header is not a string");
    }
    const chunks = [];
    for await (const chunk of request) {
      chunks.push(typeof chunk === "string" ? Buffer.from(chunk) : chunk);
    }
    const body = Buffer.concat(chunks).toString("utf8");
    const isValid = await receiver.verify({
      signature,
      body,
      clockTolerance: _optionalChain([config, 'optionalAccess', _3 => _3.clockTolerance])
    });
    if (!isValid) {
      response.status(BAD_REQUEST);
      response.send("Invalid signature");
      response.end();
      return;
    }
    try {
      request.body = request.headers["content-type"] === "application/json" ? JSON.parse(body) : body;
    } catch (e) {
      request.body = body;
    }
    return handler(request, response);
  };
}
function verifySignatureEdge(handler, config) {
  const currentSigningKey = _nullishCoalesce(_optionalChain([config, 'optionalAccess', _4 => _4.currentSigningKey]), () => ( process.env.QSTASH_CURRENT_SIGNING_KEY));
  if (!currentSigningKey) {
    throw new Error(
      "currentSigningKey is required, either in the config or as env variable QSTASH_CURRENT_SIGNING_KEY"
    );
  }
  const nextSigningKey = _nullishCoalesce(_optionalChain([config, 'optionalAccess', _5 => _5.nextSigningKey]), () => ( process.env.QSTASH_NEXT_SIGNING_KEY));
  if (!nextSigningKey) {
    throw new Error(
      "nextSigningKey is required, either in the config or as env variable QSTASH_NEXT_SIGNING_KEY"
    );
  }
  const receiver = new (0, _chunkUUR7N6E6js.Receiver)({
    currentSigningKey,
    nextSigningKey
  });
  return async (request, nfe) => {
    const requestClone = request.clone();
    const signature = request.headers.get("upstash-signature");
    if (!signature) {
      return new (0, _server.NextResponse)(new TextEncoder().encode("`Upstash-Signature` header is missing"), {
        status: 403
      });
    }
    if (typeof signature !== "string") {
      throw new TypeError("`Upstash-Signature` header is not a string");
    }
    const body = await requestClone.text();
    const isValid = await receiver.verify({
      signature,
      body,
      clockTolerance: _optionalChain([config, 'optionalAccess', _6 => _6.clockTolerance])
    });
    if (!isValid) {
      return new (0, _server.NextResponse)(new TextEncoder().encode("invalid signature"), { status: 403 });
    }
    return handler(request, nfe);
  };
}
function verifySignatureAppRouter(handler, config) {
  const currentSigningKey = _nullishCoalesce(_optionalChain([config, 'optionalAccess', _7 => _7.currentSigningKey]), () => ( process.env.QSTASH_CURRENT_SIGNING_KEY));
  if (!currentSigningKey) {
    throw new Error(
      "currentSigningKey is required, either in the config or as env variable QSTASH_CURRENT_SIGNING_KEY"
    );
  }
  const nextSigningKey = _nullishCoalesce(_optionalChain([config, 'optionalAccess', _8 => _8.nextSigningKey]), () => ( process.env.QSTASH_NEXT_SIGNING_KEY));
  if (!nextSigningKey) {
    throw new Error(
      "nextSigningKey is required, either in the config or as env variable QSTASH_NEXT_SIGNING_KEY"
    );
  }
  const receiver = new (0, _chunkUUR7N6E6js.Receiver)({
    currentSigningKey,
    nextSigningKey
  });
  return async (request) => {
    const requestClone = request.clone();
    const signature = request.headers.get("upstash-signature");
    if (!signature) {
      return new (0, _server.NextResponse)(new TextEncoder().encode("`Upstash-Signature` header is missing"), {
        status: 403
      });
    }
    if (typeof signature !== "string") {
      throw new TypeError("`Upstash-Signature` header is not a string");
    }
    const body = await requestClone.text();
    const isValid = await receiver.verify({
      signature,
      body,
      clockTolerance: _optionalChain([config, 'optionalAccess', _9 => _9.clockTolerance])
    });
    if (!isValid) {
      return new (0, _server.NextResponse)(new TextEncoder().encode("invalid signature"), { status: 403 });
    }
    return handler(request);
  };
}




exports.verifySignature = verifySignature; exports.verifySignatureAppRouter = verifySignatureAppRouter; exports.verifySignatureEdge = verifySignatureEdge;
