/**
 * Necessary to verify the signature of a request.
 */
type ReceiverConfig = {
    /**
     * The current signing key. Get it from `https://console.upstash.com/qstash
     */
    currentSigningKey: string;
    /**
     * The next signing key. Get it from `https://console.upstash.com/qstash
     */
    nextSigningKey: string;
};
type VerifyRequest = {
    /**
     * The signature from the `upstash-signature` header.
     */
    signature: string;
    /**
     * The raw request body.
     */
    body: string;
    /**
     * URL of the endpoint where the request was sent to.
     *
     * Omit empty to disable checking the url.
     */
    url?: string;
    /**
     * Number of seconds to tolerate when checking `nbf` and `exp` claims, to deal with small clock differences among different servers
     *
     * @default 0
     */
    clockTolerance?: number;
};
declare class SignatureError extends Error {
    constructor(message: string);
}
/**
 * Receiver offers a simple way to verify the signature of a request.
 */
declare class Receiver {
    private readonly currentSigningKey;
    private readonly nextSigningKey;
    constructor(config: ReceiverConfig);
    /**
     * Verify the signature of a request.
     *
     * Tries to verify the signature with the current signing key.
     * If that fails, maybe because you have rotated the keys recently, it will
     * try to verify the signature with the next signing key.
     *
     * If that fails, the signature is invalid and a `SignatureError` is thrown.
     */
    verify(request: VerifyRequest): Promise<boolean>;
    /**
     * Verify signature with a specific signing key
     */
    private verifyWithKey;
}

type State = "CREATED" | "ACTIVE" | "DELIVERED" | "ERROR" | "RETRY" | "FAILED";
type Event = {
    time: number;
    state: State;
    messageId: string;
    nextDeliveryTime?: number;
    error?: string;
    url: string;
    urlGroup?: string;
    topicName?: string;
    endpointName?: string;
    header?: Record<string, string>;
    body?: string;
};
type EventPayload = Omit<Event, "urlGroup"> & {
    topicName: string;
};
type GetEventsPayload = {
    cursor?: number;
    events: EventPayload[];
};
type WithCursor<T> = T & {
    cursor?: number;
};
type BodyInit = Blob | FormData | URLSearchParams | ReadableStream<Uint8Array> | string;
type HeadersInit = Headers | Record<string, string> | [string, string][] | IterableIterator<[string, string]>;
type RequestOptions = RequestInit & {
    backend?: string;
};
type ChatRateLimit = {
    "limit-requests": string | null;
    "limit-tokens": string | null;
    "remaining-requests": string | null;
    "remaining-tokens": string | null;
    "reset-requests": string | null;
    "reset-tokens": string | null;
};
type RateLimit = {
    limit: string | null;
    remaining: string | null;
    reset: string | null;
};

type ProviderReturnType = {
    owner: "upstash" | "openai" | "custom";
    baseUrl: string;
    token: string;
};
declare const upstash: () => {
    owner: "upstash";
    baseUrl: "https://qstash.upstash.io/llm";
    token: string;
};
declare const openai: ({ token, }: {
    token: string;
}) => {
    owner: "openai";
    baseUrl: "https://api.openai.com";
    token: string;
};
declare const custom: ({ baseUrl, token, }: {
    token: string;
    baseUrl: string;
}) => {
    owner: "custom";
    baseUrl: string;
    token: string;
};

type ChatCompletionMessage = {
    role: "system" | "assistant" | "user";
    content: string;
};
type ChatModel = "meta-llama/Meta-Llama-3-8B-Instruct" | "mistralai/Mistral-7B-Instruct-v0.2";
type ChatResponseFormat = {
    type: "text" | "json_object";
};
type TopLogprob = {
    token: string;
    bytes: number[];
    logprob: number;
};
type ChatCompletionTokenLogprob = {
    token: string;
    bytes: number[];
    logprob: number;
    top_logprobs: TopLogprob[];
};
type ChoiceLogprobs = {
    content: ChatCompletionTokenLogprob[];
};
type Choice = {
    finish_reason: "stop" | "length";
    index: number;
    logprobs: ChoiceLogprobs;
    message: ChatCompletionMessage;
};
type CompletionUsage = {
    completion_tokens: number;
    prompt_tokens: number;
    total_tokens: number;
};
type ChatCompletion = {
    id: string;
    choices: Choice[];
    created: number;
    model: string;
    object: "chat.completion";
    system_fingerprint: string;
    usage: CompletionUsage;
};
type ChunkChoice = {
    delta: ChatCompletionMessage;
    finish_reason: "stop" | "length";
    index: number;
    logprobs: ChoiceLogprobs;
};
type ChatCompletionChunk = {
    id: string;
    choices: ChunkChoice[];
    created: number;
    model: string;
    object: "chat.completion.chunk";
    system_fingerprint: string;
    usage: CompletionUsage;
};
type StreamEnabled = {
    stream: true;
};
type StreamDisabled = {
    stream: false;
} | object;
type StreamParameter = StreamEnabled | StreamDisabled;
type OpenAIChatModel = "gpt-4-turbo" | "gpt-4-turbo-2024-04-09" | "gpt-4-0125-preview" | "gpt-4-turbo-preview" | "gpt-4-1106-preview" | "gpt-4-vision-preview" | "gpt-4" | "gpt-4-0314" | "gpt-4-0613" | "gpt-4-32k" | "gpt-4-32k-0314" | "gpt-4-32k-0613" | "gpt-3.5-turbo" | "gpt-3.5-turbo-16k" | "gpt-3.5-turbo-0301" | "gpt-3.5-turbo-0613" | "gpt-3.5-turbo-1106" | "gpt-3.5-turbo-0125" | "gpt-3.5-turbo-16k-0613";
type ChatRequestCommonFields = {
    frequency_penalty?: number;
    logit_bias?: Record<string, number>;
    logprobs?: boolean;
    top_logprobs?: number;
    max_tokens?: number;
    n?: number;
    presence_penalty?: number;
    response_format?: ChatResponseFormat;
    seed?: number;
    stop?: string | string[];
    temperature?: number;
    top_p?: number;
};
type PromptChatRequestFields = ChatRequestCommonFields & {
    system: string;
    user: string;
};
type ChatRequestFields = ChatRequestCommonFields & {
    messages: ChatCompletionMessage[];
};
type ChatRequestProviders = {
    provider: ProviderReturnType;
    model: OpenAIChatModel;
} | {
    provider: ProviderReturnType;
    model: string;
} | {
    provider: ProviderReturnType;
    model: ChatModel;
};
type PromptChatRequest<TStream extends StreamParameter> = ChatRequestProviders & PromptChatRequestFields & TStream;
type ChatRequest<TStream extends StreamParameter> = ChatRequestProviders & ChatRequestFields & TStream;

type UpstashRequest = {
    /**
     * The path to the resource.
     */
    path: string[];
    /**
     * A BodyInit object or null to set request's body.
     */
    body?: BodyInit | null;
    /**
     * A Headers object, an object literal, or an array of two-item arrays to set
     * request's headers.
     */
    headers?: HeadersInit;
    /**
     * A boolean to set request's keepalive.
     */
    keepalive?: boolean;
    /**
     * A string to set request's method.
     */
    method?: "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
    query?: Record<string, string | number | boolean | undefined>;
    /**
     * if enabled, call `res.json()`
     *
     * @default true
     */
    parseResponseAsJson?: boolean;
    baseUrl?: string;
};
type UpstashResponse<TResult> = TResult & {
    error?: string;
};
type Requester = {
    request: <TResult = unknown>(request: UpstashRequest) => Promise<UpstashResponse<TResult>>;
    requestStream: (request: UpstashRequest) => AsyncIterable<ChatCompletionChunk>;
};
type RetryConfig = false | {
    /**
     * The number of retries to attempt before giving up.
     *
     * @default 5
     */
    retries?: number;
    /**
     * A backoff function receives the current retry cound and returns a number in milliseconds to wait before retrying.
     *
     * @default
     * ```ts
     * Math.exp(retryCount) * 50
     * ```
     */
    backoff?: (retryCount: number) => number;
};

type Message = {
    /**
     * A unique identifier for this message.
     */
    messageId: string;
    /**
     * The url group name if this message was sent to a urlGroup.
     */
    urlGroup?: string;
    /**
     * Deprecated. The topic name if this message was sent to a urlGroup. Use urlGroup instead
     */
    topicName?: string;
    /**
     * The url where this message is sent to.
     */
    url: string;
    /**
     * The endpoint name of the message if the endpoint is given a
     * name within the url group.
     */
    endpointName?: string;
    /**
     * The api name if this message was sent to an api
     */
    api?: string;
    /**
     * The http method used to deliver the message
     */
    method?: "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
    /**
     * The http headers sent along with the message to your API.
     */
    header?: Record<string, string[]>;
    /**
     * The http body sent to your API
     */
    body?: string;
    /**
     * The base64 encoded body if the body contains non-UTF-8 characters,
     * `None` otherwise.
     */
    bodyBase64?: string;
    /**
     * Maxmimum number of retries.
     */
    maxRetries?: number;
    /**
     * A unix timestamp (milliseconds) after which this message may get delivered.
     */
    notBefore?: number;
    /**
     * A unix timestamp (milliseconds) when this messages was created.
     */
    createdAt: number;
    /**
     * The callback url if configured.
     */
    callback?: string;
    /**
     * The failure callback url if configured.
     */
    failureCallback?: string;
    /**
     * The queue name if this message was sent to a queue.
     */
    queueName?: string;
    /**
     * The scheduleId of the message if the message is triggered by a schedule
     */
    scheduleId?: string;
    /**
     * IP address of the publisher of this message
     */
    callerIp?: string;
};
type MessagePayload = Omit<Message, "urlGroup"> & {
    topicName: string;
};
declare class Messages {
    private readonly http;
    constructor(http: Requester);
    /**
     * Get a message
     */
    get(messageId: string): Promise<Message>;
    /**
     * Cancel a message
     */
    delete(messageId: string): Promise<void>;
    deleteMany(messageIds: string[]): Promise<number>;
    deleteAll(): Promise<number>;
}

type DlqMessage = Message & {
    /**
     * The unique id within the DLQ
     */
    dlqId: string;
    /**
     * The HTTP status code of the last failed delivery attempt
     */
    responseStatus?: number;
    /**
     * The response headers of the last failed delivery attempt
     */
    responseHeader?: Record<string, string[]>;
    /**
     * The response body of the last failed delivery attempt if it is
     * composed of UTF-8 characters only, `None` otherwise.
     */
    responseBody?: string;
    /**
     * The base64 encoded response body of the last failed delivery attempt
     * if the response body contains non-UTF-8 characters, `None` otherwise.
     */
    responseBodyBase64?: string;
};
type DLQFilter = {
    /**
     * Filter DLQ entries by message id
     */
    messageId?: string;
    /**
     * Filter DLQ entries by url
     */
    url?: string;
    /**
     * Filter DLQ entries by url group name
     */
    urlGroup?: string;
    /**
     * Filter DLQ entries by api name
     */
    api?: string;
    /**
     * Filter DLQ entries by queue name
     */
    queueName?: string;
    /**
     * Filter DLQ entries by schedule id
     */
    scheduleId?: string;
    /**
     * Filter DLQ entries by starting time, in milliseconds
     */
    fromDate?: number;
    /**
     * Filter DLQ entries by ending time, in milliseconds
     */
    toDate?: number;
    /**
     * Filter DLQ entries by HTTP status of the response
     */
    responseStatus?: number;
    /**
     * Filter DLQ entries by IP address of the publisher of the message
     */
    callerIp?: string;
};
declare class DLQ {
    private readonly http;
    constructor(http: Requester);
    /**
     * List messages in the dlq
     */
    listMessages(options?: {
        cursor?: string;
        count?: number;
        filter?: DLQFilter;
    }): Promise<{
        messages: DlqMessage[];
        cursor?: string;
    }>;
    /**
     * Remove a message from the dlq using it's `dlqId`
     */
    delete(dlqMessageId: string): Promise<void>;
    /**
     * Remove multiple messages from the dlq using their `dlqId`s
     */
    deleteMany(request: {
        dlqIds: string[];
    }): Promise<{
        deleted: number;
    }>;
}

declare class Chat {
    private http;
    private token;
    constructor(http: Requester, token: string);
    private static toChatRequest;
    /**
     * Calls the Upstash completions api given a ChatRequest.
     *
     * Returns a ChatCompletion or a stream of ChatCompletionChunks
     * if stream is enabled.
     *
     * @param request ChatRequest with messages
     * @returns Chat completion or stream
     */
    create: <TStream extends StreamParameter>(request: ChatRequest<TStream>) => Promise<TStream extends StreamEnabled ? AsyncIterable<ChatCompletionChunk> : ChatCompletion>;
    /**
     * Calls the Upstash completions api given a ChatRequest.
     *
     * Returns a ChatCompletion or a stream of ChatCompletionChunks
     * if stream is enabled.
     *
     * @param request ChatRequest with messages
     * @returns Chat completion or stream
     */
    private createThirdParty;
    /**
     * Calls the Upstash completions api given a PromptRequest.
     *
     * Returns a ChatCompletion or a stream of ChatCompletionChunks
     * if stream is enabled.
     *
     * @param request PromptRequest with system and user messages.
     *    Note that system parameter shouldn't be passed in the case of
     *    mistralai/Mistral-7B-Instruct-v0.2 model.
     * @returns Chat completion or stream
     */
    prompt: <TStream extends StreamParameter>(request: PromptChatRequest<TStream>) => Promise<TStream extends StreamEnabled ? AsyncIterable<ChatCompletionChunk> : ChatCompletion>;
}

type QueueResponse = {
    createdAt: number;
    updatedAt: number;
    name: string;
    parallelism: number;
    lag: number;
    paused?: boolean;
};
type UpsertQueueRequest = {
    /**
     * The number of parallel consumers consuming from the queue.
     *
     * @default 1
     */
    parallelism?: number;
    /**
     * Whether to pause the queue or not. A paused queue will not
     * deliver new messages until it is resumed.
     *
     * @default false
     */
    paused?: boolean;
};
declare class Queue {
    private readonly http;
    private readonly queueName;
    constructor(http: Requester, queueName?: string);
    /**
     * Create or update the queue
     */
    upsert(request: UpsertQueueRequest): Promise<void>;
    /**
     * Get the queue details
     */
    get(): Promise<QueueResponse>;
    /**
     * List queues
     */
    list(): Promise<QueueResponse[]>;
    /**
     * Delete the queue
     */
    delete(): Promise<void>;
    /**
     * Enqueue a message to a queue.
     */
    enqueue<TRequest extends PublishRequest>(request: TRequest): Promise<PublishResponse<TRequest>>;
    /**
     * Enqueue a message to a queue, serializing the body to JSON.
     */
    enqueueJSON<TBody = unknown, TRequest extends PublishRequest<TBody> = PublishRequest<TBody>>(request: TRequest): Promise<PublishResponse<TRequest>>;
    /**
     * Pauses the queue.
     *
     * A paused queue will not deliver messages until
     * it is resumed.
     */
    pause(): Promise<void>;
    /**
     * Resumes the queue.
     */
    resume(): Promise<void>;
}

type Schedule = {
    scheduleId: string;
    cron: string;
    createdAt: number;
    destination: string;
    method: string;
    header?: Record<string, string[]>;
    body?: string;
    bodyBase64?: string;
    retries: number;
    delay?: number;
    callback?: string;
    failureCallback?: string;
    callerIp?: string;
    isPaused: true | undefined;
};
type CreateScheduleRequest = {
    /**
     * Either a URL or urlGroup name
     */
    destination: string;
    /**
     * The message to send.
     *
     * This can be anything, but please set the `Content-Type` header accordingly.
     *
     * You can leave this empty if you want to send a message with no body.
     */
    body?: BodyInit;
    /**
     * Optionally send along headers with the message.
     * These headers will be sent to your destination.
     *
     * We highly recommend sending a `Content-Type` header along, as this will help your destination
     * server to understand the content of the message.
     */
    headers?: HeadersInit;
    /**
     * Optionally delay the delivery of this message.
     *
     * In seconds.
     *
     * @default undefined
     */
    delay?: number;
    /**
     * In case your destination server is unavailable or returns a status code outside of the 200-299
     * range, we will retry the request after a certain amount of time.
     *
     * Configure how many times you would like the delivery to be retried
     *
     * @default The maximum retry quota associated with your account.
     */
    retries?: number;
    /**
     * Use a callback url to forward the response of your destination server to your callback url.
     *
     * The callback url must be publicly accessible
     *
     * @default undefined
     */
    callback?: string;
    /**
     * Use a failure callback url to handle messages that could not be delivered.
     *
     * The failure callback url must be publicly accessible
     *
     * @default undefined
     */
    failureCallback?: string;
    /**
     * The method to use when sending a request to your API
     *
     * @default `POST`
     */
    method?: "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
    /**
     * Specify a cron expression to repeatedly send this message to the destination.
     */
    cron: string;
    /**
     * The HTTP timeout value to use while calling the destination URL.
     * When a timeout is specified, it will be used instead of the maximum timeout
     * value permitted by the QStash plan. It is useful in scenarios, where a message
     * should be delivered with a shorter timeout.
     *
     * In seconds.
     *
     * @default undefined
     */
    timeout?: number;
};
declare class Schedules {
    private readonly http;
    constructor(http: Requester);
    /**
     * Create a schedule
     */
    create(request: CreateScheduleRequest): Promise<{
        scheduleId: string;
    }>;
    /**
     * Get a schedule
     */
    get(scheduleId: string): Promise<Schedule>;
    /**
     * List your schedules
     */
    list(): Promise<Schedule[]>;
    /**
     * Delete a schedule
     */
    delete(scheduleId: string): Promise<void>;
    /**
     * Pauses the schedule.
     *
     * A paused schedule will not deliver messages until
     * it is resumed.
     */
    pause({ schedule }: {
        schedule: string;
    }): Promise<void>;
    /**
     * Resumes the schedule.
     */
    resume({ schedule }: {
        schedule: string;
    }): Promise<void>;
}

type Endpoint = {
    /**
     * The name of the endpoint (optional)
     */
    name?: string;
    /**
     * The url of the endpoint
     */
    url: string;
};
type AddEndpointsRequest = {
    /**
     * The name of the url group.
     * Must be unique and only contain alphanumeric, hyphen, underscore and periods.
     */
    name: string;
    endpoints: Endpoint[];
};
type RemoveEndpointsRequest = {
    /**
     * The name of the url group.
     * Must be unique and only contain alphanumeric, hyphen, underscore and periods.
     */
    name: string;
    endpoints: ({
        name: string;
        url?: string;
    } | {
        name?: string;
        url: string;
    })[];
};
type UrlGroup = {
    /**
     * A unix timestamp (milliseconds)
     */
    createdAt: number;
    /**
     * A unix timestamp (milliseconds)
     */
    updatedAt: number;
    /**
     * The name of this url group.
     */
    name: string;
    /**
     * A list of all subscribed endpoints
     */
    endpoints: Endpoint[];
};
declare class UrlGroups {
    private readonly http;
    constructor(http: Requester);
    /**
     * Create a new url group with the given name and endpoints
     */
    addEndpoints(request: AddEndpointsRequest): Promise<void>;
    /**
     * Remove endpoints from a url group.
     */
    removeEndpoints(request: RemoveEndpointsRequest): Promise<void>;
    /**
     * Get a list of all url groups.
     */
    list(): Promise<UrlGroup[]>;
    /**
     * Get a single url group
     */
    get(name: string): Promise<UrlGroup>;
    /**
     * Delete a url group
     */
    delete(name: string): Promise<void>;
}

type ClientConfig = {
    /**
     * Url of the qstash api server.
     *
     * This is only used for testing.
     *
     * @default "https://qstash.upstash.io"
     */
    baseUrl?: string;
    /**
     * The authorization token from the upstash console.
     */
    token: string;
    /**
     * Configure how the client should retry requests.
     */
    retry?: RetryConfig;
};
type PublishBatchRequest<TBody = BodyInit> = PublishRequest<TBody> & {
    queueName?: string;
};
type PublishRequest<TBody = BodyInit> = {
    /**
     * The message to send.
     *
     * This can be anything, but please set the `Content-Type` header accordingly.
     *
     * You can leave this empty if you want to send a message with no body.
     */
    body?: TBody;
    /**
     * Optionally send along headers with the message.
     * These headers will be sent to your destination.
     *
     * We highly recommend sending a `Content-Type` header along, as this will help your destination
     * server to understand the content of the message.
     */
    headers?: HeadersInit;
    /**
     * Optionally delay the delivery of this message.
     *
     * In seconds.
     *
     * @default undefined
     */
    delay?: number;
    /**
     * Optionally set the absolute delay of this message.
     * This will override the delay option.
     * The message will not delivered until the specified time.
     *
     * Unix timestamp in seconds.
     *
     * @default undefined
     */
    notBefore?: number;
    /**
     * Provide a unique id for deduplication. This id will be used to detect duplicate messages.
     * If a duplicate message is detected, the request will be accepted but not enqueued.
     *
     * We store deduplication ids for 90 days. Afterwards it is possible that the message with the
     * same deduplication id is delivered again.
     *
     * When scheduling a message, the deduplication happens before the schedule is created.
     *
     * @default undefined
     */
    deduplicationId?: string;
    /**
     * If true, the message content will get hashed and used as deduplication id.
     * If a duplicate message is detected, the request will be accepted but not enqueued.
     *
     * The content based hash includes the following values:
     *    - All headers, except Upstash-Authorization, this includes all headers you are sending.
     *    - The entire raw request body The destination from the url path
     *
     * We store deduplication ids for 90 days. Afterwards it is possible that the message with the
     * same deduplication id is delivered again.
     *
     * When scheduling a message, the deduplication happens before the schedule is created.
     *
     * @default false
     */
    contentBasedDeduplication?: boolean;
    /**
     * In case your destination server is unavaialble or returns a status code outside of the 200-299
     * range, we will retry the request after a certain amount of time.
     *
     * Configure how many times you would like the delivery to be retried up to the maxRetries limit
     * defined in your plan.
     *
     * @default 3
     */
    retries?: number;
    /**
     * Use a callback url to forward the response of your destination server to your callback url.
     *
     * The callback url must be publicly accessible
     *
     * @default undefined
     */
    callback?: string;
    /**
     * Use a failure callback url to handle messages that could not be delivered.
     *
     * The failure callback url must be publicly accessible
     *
     * @default undefined
     */
    failureCallback?: string;
    /**
     * The method to use when sending a request to your API
     *
     * @default `POST`
     */
    method?: "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
    /**
     * The HTTP timeout value to use while calling the destination URL.
     * When a timeout is specified, it will be used instead of the maximum timeout
     * value permitted by the QStash plan. It is useful in scenarios, where a message
     * should be delivered with a shorter timeout.
     *
     * In seconds.
     *
     * @default undefined
     */
    timeout?: number;
} & ({
    /**
     * The url where the message should be sent to.
     */
    url: string;
    urlGroup?: never;
    api?: never;
    topic?: never;
} | {
    url?: never;
    /**
     * The url group the message should be sent to.
     */
    urlGroup: string;
    api?: never;
    topic?: never;
} | {
    url?: string;
    urlGroup?: never;
    /**
     * The api endpoint the request should be sent to.
     */
    api: {
        name: "llm";
        provider?: ProviderReturnType;
    };
    topic?: never;
} | {
    url?: never;
    urlGroup?: never;
    api: never;
    /**
     * Deprecated. The topic the message should be sent to. Same as urlGroup
     */
    topic?: string;
});
type PublishJsonRequest = Omit<PublishRequest, "body"> & {
    /**
     * The message to send.
     * This can be anything as long as it can be serialized to JSON.
     */
    body: unknown;
};
type EventsRequest = {
    cursor?: number;
    filter?: EventsRequestFilter;
};
type EventsRequestFilter = {
    messageId?: string;
    state?: State;
    url?: string;
    urlGroup?: string;
    topicName?: string;
    api?: string;
    scheduleId?: string;
    queueName?: string;
    fromDate?: number;
    toDate?: number;
    count?: number;
};
type GetEventsResponse = {
    cursor?: number;
    events: Event[];
};
type QueueRequest = {
    queueName?: string;
};
declare class Client {
    http: Requester;
    private token;
    constructor(config: ClientConfig);
    /**
     * Access the urlGroup API.
     *
     * Create, read, update or delete urlGroups.
     */
    get urlGroups(): UrlGroups;
    /**
     * Deprecated. Use urlGroups instead.
     *
     * Access the topic API.
     *
     * Create, read, update or delete topics.
     */
    get topics(): UrlGroups;
    /**
     * Access the dlq API.
     *
     * List or remove messages from the DLQ.
     */
    get dlq(): DLQ;
    /**
     * Access the message API.
     *
     * Read or cancel messages.
     */
    get messages(): Messages;
    /**
     * Access the schedule API.
     *
     * Create, read or delete schedules.
     */
    get schedules(): Schedules;
    /**
     * Access the queue API.
     *
     * Create, read, update or delete queues.
     */
    queue(request?: QueueRequest): Queue;
    /**
     * Access the Chat API
     *
     * Call the create or prompt methods
     */
    chat(): Chat;
    publish<TRequest extends PublishRequest>(request: TRequest): Promise<PublishResponse<TRequest>>;
    /**
     * publishJSON is a utility wrapper around `publish` that automatically serializes the body
     * and sets the `Content-Type` header to `application/json`.
     */
    publishJSON<TBody = unknown, TRequest extends PublishRequest<TBody> = PublishRequest<TBody>>(request: TRequest): Promise<PublishResponse<TRequest>>;
    /**
     * Batch publish messages to QStash.
     */
    batch(request: PublishBatchRequest[]): Promise<PublishResponse<PublishRequest>[]>;
    /**
     * Batch publish messages to QStash, serializing each body to JSON.
     */
    batchJSON<TBody = unknown, TRequest extends PublishBatchRequest<TBody> = PublishBatchRequest<TBody>>(request: TRequest[]): Promise<PublishResponse<TRequest>[]>;
    /**
     * Retrieve your logs.
     *
     * The logs endpoint is paginated and returns only 100 logs at a time.
     * If you want to receive more logs, you can use the cursor to paginate.
     *
     * The cursor is a unix timestamp with millisecond precision
     *
     * @example
     * ```ts
     * let cursor = Date.now()
     * const logs: Log[] = []
     * while (cursor > 0) {
     *   const res = await qstash.logs({ cursor })
     *   logs.push(...res.logs)
     *   cursor = res.cursor ?? 0
     * }
     * ```
     */
    events(request?: EventsRequest): Promise<GetEventsResponse>;
}
type PublishToApiResponse = {
    messageId: string;
};
type PublishToUrlResponse = PublishToApiResponse & {
    url: string;
    deduplicated?: boolean;
};
type PublishToUrlGroupsResponse = PublishToUrlResponse[];
type PublishResponse<TRequest> = TRequest extends {
    url: string;
} ? PublishToUrlResponse : TRequest extends {
    urlGroup: string;
} ? PublishToUrlGroupsResponse : PublishToApiResponse;

/**
 * Result of 500 Internal Server Error
 */
declare class QstashError extends Error {
    constructor(message: string);
}
declare class QstashRatelimitError extends QstashError {
    limit: string | null;
    remaining: string | null;
    reset: string | null;
    constructor(args: RateLimit);
}
declare class QstashChatRatelimitError extends QstashError {
    limitRequests: string | null;
    limitTokens: string | null;
    remainingRequests: string | null;
    remainingTokens: string | null;
    resetRequests: string | null;
    resetTokens: string | null;
    constructor(args: ChatRateLimit);
}
declare class QstashDailyRatelimitError extends QstashError {
    limit: string | null;
    remaining: string | null;
    reset: string | null;
    constructor(args: RateLimit);
}

export { type AddEndpointsRequest, type BodyInit, Chat, type ChatCompletion, type ChatCompletionChunk, type ChatCompletionMessage, type ChatRateLimit, type ChatRequest, Client, type CreateScheduleRequest, type Endpoint, type Event, type EventPayload, type EventsRequest, type GetEventsPayload, type GetEventsResponse, type HeadersInit, type Message, type MessagePayload, Messages, type OpenAIChatModel, type PromptChatRequest, type ProviderReturnType, type PublishBatchRequest, type PublishJsonRequest, type PublishRequest, type PublishResponse, type PublishToApiResponse, type PublishToUrlGroupsResponse, type PublishToUrlResponse, QstashChatRatelimitError, QstashDailyRatelimitError, QstashError, QstashRatelimitError, type QueueRequest, type RateLimit, Receiver, type ReceiverConfig, type RemoveEndpointsRequest, type RequestOptions, type Schedule, Schedules, SignatureError, type State, type StreamDisabled, type StreamEnabled, type StreamParameter, type UrlGroup, UrlGroups, type VerifyRequest, type WithCursor, custom, openai, upstash };
