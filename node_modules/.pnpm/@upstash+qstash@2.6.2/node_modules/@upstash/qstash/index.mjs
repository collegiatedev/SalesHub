import {
  Receiver,
  SignatureError
} from "./chunk-CP4IU45K.mjs";

// src/client/dlq.ts
var DLQ = class {
  http;
  constructor(http) {
    this.http = http;
  }
  /**
   * List messages in the dlq
   */
  async listMessages(options) {
    const filterPayload = {
      ...options?.filter,
      topicName: options?.filter?.urlGroup
    };
    const messagesPayload = await this.http.request({
      method: "GET",
      path: ["v2", "dlq"],
      query: {
        cursor: options?.cursor,
        count: options?.count,
        ...filterPayload
      }
    });
    return {
      messages: messagesPayload.messages.map((message) => {
        return {
          ...message,
          urlGroup: message.topicName
        };
      }),
      cursor: messagesPayload.cursor
    };
  }
  /**
   * Remove a message from the dlq using it's `dlqId`
   */
  async delete(dlqMessageId) {
    return await this.http.request({
      method: "DELETE",
      path: ["v2", "dlq", dlqMessageId],
      parseResponseAsJson: false
      // there is no response
    });
  }
  /**
   * Remove multiple messages from the dlq using their `dlqId`s
   */
  async deleteMany(request) {
    return await this.http.request({
      method: "DELETE",
      path: ["v2", "dlq"],
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ dlqIds: request.dlqIds })
    });
  }
};

// src/client/error.ts
var QstashError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "QstashError";
  }
};
var QstashRatelimitError = class extends QstashError {
  limit;
  remaining;
  reset;
  constructor(args) {
    super(`Exceeded burst rate limit. ${JSON.stringify(args)} `);
    this.limit = args.limit;
    this.remaining = args.remaining;
    this.reset = args.reset;
  }
};
var QstashChatRatelimitError = class extends QstashError {
  limitRequests;
  limitTokens;
  remainingRequests;
  remainingTokens;
  resetRequests;
  resetTokens;
  constructor(args) {
    super(`Exceeded chat rate limit. ${JSON.stringify(args)} `);
    this.limitRequests = args["limit-requests"];
    this.limitTokens = args["limit-tokens"];
    this.remainingRequests = args["remaining-requests"];
    this.remainingTokens = args["remaining-tokens"];
    this.resetRequests = args["reset-requests"];
    this.resetTokens = args["reset-tokens"];
  }
};
var QstashDailyRatelimitError = class extends QstashError {
  limit;
  remaining;
  reset;
  constructor(args) {
    super(`Exceeded daily rate limit. ${JSON.stringify(args)} `);
    this.limit = args.limit;
    this.remaining = args.remaining;
    this.reset = args.reset;
  }
};

// src/client/http.ts
var HttpClient = class {
  baseUrl;
  authorization;
  options;
  retry;
  constructor(config) {
    this.baseUrl = config.baseUrl.replace(/\/$/, "");
    this.authorization = config.authorization;
    this.retry = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    typeof config.retry === "boolean" && !config.retry ? {
      attempts: 1,
      backoff: () => 0
    } : {
      attempts: config.retry?.retries ? config.retry.retries + 1 : 5,
      backoff: config.retry?.backoff ?? ((retryCount) => Math.exp(retryCount) * 50)
    };
  }
  async request(request) {
    const { response } = await this.requestWithBackoff(request);
    if (request.parseResponseAsJson === false) {
      return void 0;
    }
    return await response.json();
  }
  async *requestStream(request) {
    const { response } = await this.requestWithBackoff(request);
    if (!response.body) {
      throw new Error("No response body");
    }
    const body = response.body;
    const reader = body.getReader();
    const decoder = new TextDecoder();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        const chunkText = decoder.decode(value, { stream: true });
        const chunks = chunkText.split("\n").filter(Boolean);
        for (const chunk of chunks) {
          if (chunk.startsWith("data: ")) {
            const data = chunk.slice(6);
            if (data === "[DONE]") {
              break;
            }
            yield JSON.parse(data);
          }
        }
      }
    } finally {
      await reader.cancel();
    }
  }
  requestWithBackoff = async (request) => {
    const [url, requestOptions] = this.processRequest(request);
    let response = void 0;
    let error = void 0;
    for (let index = 0; index < this.retry.attempts; index++) {
      try {
        response = await fetch(url.toString(), requestOptions);
        break;
      } catch (error_) {
        error = error_;
        await new Promise((r) => setTimeout(r, this.retry.backoff(index)));
      }
    }
    if (!response) {
      throw error ?? new Error("Exhausted all retries");
    }
    await this.checkResponse(response);
    return {
      response,
      error
    };
  };
  processRequest = (request) => {
    const headers = new Headers(request.headers);
    if (!headers.has("Authorization")) {
      headers.set("Authorization", this.authorization);
    }
    const requestOptions = {
      method: request.method,
      headers,
      body: request.body,
      keepalive: request.keepalive
    };
    const url = new URL([request.baseUrl ?? this.baseUrl, ...request.path].join("/"));
    if (request.query) {
      for (const [key, value] of Object.entries(request.query)) {
        if (value !== void 0) {
          url.searchParams.set(key, value.toString());
        }
      }
    }
    return [url.toString(), requestOptions];
  };
  async checkResponse(response) {
    if (response.status === 429) {
      if (response.headers.get("x-ratelimit-limit-requests")) {
        throw new QstashChatRatelimitError({
          "limit-requests": response.headers.get("x-ratelimit-limit-requests"),
          "limit-tokens": response.headers.get("x-ratelimit-limit-tokens"),
          "remaining-requests": response.headers.get("x-ratelimit-remaining-requests"),
          "remaining-tokens": response.headers.get("x-ratelimit-remaining-tokens"),
          "reset-requests": response.headers.get("x-ratelimit-reset-requests"),
          "reset-tokens": response.headers.get("x-ratelimit-reset-tokens")
        });
      } else if (response.headers.get("RateLimit-Limit")) {
        throw new QstashDailyRatelimitError({
          limit: response.headers.get("RateLimit-Limit"),
          remaining: response.headers.get("RateLimit-Remaining"),
          reset: response.headers.get("RateLimit-Reset")
        });
      }
      throw new QstashRatelimitError({
        limit: response.headers.get("Burst-RateLimit-Limit"),
        remaining: response.headers.get("Burst-RateLimit-Remaining"),
        reset: response.headers.get("Burst-RateLimit-Reset")
      });
    }
    if (response.status < 200 || response.status >= 300) {
      const body = await response.text();
      throw new QstashError(body.length > 0 ? body : `Error: status=${response.status}`);
    }
  }
};

// src/client/llm/chat.ts
var Chat = class _Chat {
  http;
  token;
  constructor(http, token) {
    this.http = http;
    this.token = token;
  }
  static toChatRequest(request) {
    const messages = [];
    messages.push(
      { role: "system", content: request.system },
      { role: "user", content: request.user }
    );
    const chatRequest = { ...request, messages };
    return chatRequest;
  }
  /**
   * Calls the Upstash completions api given a ChatRequest.
   *
   * Returns a ChatCompletion or a stream of ChatCompletionChunks
   * if stream is enabled.
   *
   * @param request ChatRequest with messages
   * @returns Chat completion or stream
   */
  create = async (request) => {
    if (request.provider.owner != "upstash")
      return this.createThirdParty(request);
    const body = JSON.stringify(request);
    if ("stream" in request && request.stream) {
      return this.http.requestStream({
        path: ["llm", "v1", "chat", "completions"],
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Connection: "keep-alive",
          Accept: "text/event-stream",
          "Cache-Control": "no-cache",
          Authorization: `Bearer ${this.token}`
        },
        body
      });
    }
    return this.http.request({
      path: ["llm", "v1", "chat", "completions"],
      method: "POST",
      headers: { "Content-Type": "application/json", Authorization: `Bearer ${this.token}` },
      body
    });
  };
  /**
   * Calls the Upstash completions api given a ChatRequest.
   *
   * Returns a ChatCompletion or a stream of ChatCompletionChunks
   * if stream is enabled.
   *
   * @param request ChatRequest with messages
   * @returns Chat completion or stream
   */
  createThirdParty = async (request) => {
    const { baseUrl, token, owner } = request.provider;
    if (owner === "upstash")
      throw new Error("Upstash is not 3rd party provider!");
    delete request.provider;
    delete request.system;
    const body = JSON.stringify(request);
    if ("stream" in request && request.stream) {
      return this.http.requestStream({
        path: ["v1", "chat", "completions"],
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Connection: "keep-alive",
          Accept: "text/event-stream",
          "Cache-Control": "no-cache",
          Authorization: `Bearer ${token}`
        },
        body,
        baseUrl
      });
    }
    return this.http.request({
      path: ["v1", "chat", "completions"],
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`
      },
      body,
      baseUrl
    });
  };
  /**
   * Calls the Upstash completions api given a PromptRequest.
   *
   * Returns a ChatCompletion or a stream of ChatCompletionChunks
   * if stream is enabled.
   *
   * @param request PromptRequest with system and user messages.
   *    Note that system parameter shouldn't be passed in the case of
   *    mistralai/Mistral-7B-Instruct-v0.2 model.
   * @returns Chat completion or stream
   */
  prompt = async (request) => {
    const chatRequest = _Chat.toChatRequest(request);
    return this.create(chatRequest);
  };
};

// src/client/llm/utils.ts
function appendLLMOptionsIfNeeded(request, headers) {
  if (request.api?.provider?.owner === "upstash") {
    request.api = { name: "llm" };
    return;
  }
  if (request.api && "provider" in request.api) {
    const provider = request.api.provider;
    if (!provider?.baseUrl)
      throw new Error("baseUrl cannot be empty or undefined!");
    if (!provider.token)
      throw new Error("token cannot be empty or undefined!");
    request.url = `${provider.baseUrl}/v1/chat/completions`;
    headers.set("Authorization", `Bearer ${provider.token}`);
  }
}

// src/client/messages.ts
var Messages = class {
  http;
  constructor(http) {
    this.http = http;
  }
  /**
   * Get a message
   */
  async get(messageId) {
    const messagePayload = await this.http.request({
      method: "GET",
      path: ["v2", "messages", messageId]
    });
    const message = {
      ...messagePayload,
      urlGroup: messagePayload.topicName
    };
    return message;
  }
  /**
   * Cancel a message
   */
  async delete(messageId) {
    return await this.http.request({
      method: "DELETE",
      path: ["v2", "messages", messageId],
      parseResponseAsJson: false
    });
  }
  async deleteMany(messageIds) {
    const result = await this.http.request({
      method: "DELETE",
      path: ["v2", "messages"],
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ messageIds })
    });
    return result.cancelled;
  }
  async deleteAll() {
    const result = await this.http.request({
      method: "DELETE",
      path: ["v2", "messages"]
    });
    return result.cancelled;
  }
};

// src/client/utils.ts
var isIgnoredHeader = (header) => {
  const lowerCaseHeader = header.toLowerCase();
  return lowerCaseHeader.startsWith("content-type") || lowerCaseHeader.startsWith("upstash-");
};
function prefixHeaders(headers) {
  const keysToBePrefixed = [...headers.keys()].filter((key) => !isIgnoredHeader(key));
  for (const key of keysToBePrefixed) {
    const value = headers.get(key);
    if (value !== null) {
      headers.set(`Upstash-Forward-${key}`, value);
    }
    headers.delete(key);
  }
  return headers;
}
function processHeaders(request) {
  const headers = prefixHeaders(new Headers(request.headers));
  headers.set("Upstash-Method", request.method ?? "POST");
  if (request.delay !== void 0) {
    headers.set("Upstash-Delay", `${request.delay.toFixed(0)}s`);
  }
  if (request.notBefore !== void 0) {
    headers.set("Upstash-Not-Before", request.notBefore.toFixed(0));
  }
  if (request.deduplicationId !== void 0) {
    headers.set("Upstash-Deduplication-Id", request.deduplicationId);
  }
  if (request.contentBasedDeduplication !== void 0) {
    headers.set("Upstash-Content-Based-Deduplication", "true");
  }
  if (request.retries !== void 0) {
    headers.set("Upstash-Retries", request.retries.toFixed(0));
  }
  if (request.callback !== void 0) {
    headers.set("Upstash-Callback", request.callback);
  }
  if (request.failureCallback !== void 0) {
    headers.set("Upstash-Failure-Callback", request.failureCallback);
  }
  if (request.timeout !== void 0) {
    headers.set("Upstash-Timeout", `${request.timeout}s`);
  }
  return headers;
}
function getRequestPath(request) {
  return request.url ?? request.urlGroup ?? request.topic ?? `api/${request.api?.name}`;
}

// src/client/queue.ts
var Queue = class {
  http;
  queueName;
  constructor(http, queueName) {
    this.http = http;
    this.queueName = queueName;
  }
  /**
   * Create or update the queue
   */
  async upsert(request) {
    if (!this.queueName) {
      throw new Error("Please provide a queue name to the Queue constructor");
    }
    const body = {
      queueName: this.queueName,
      parallelism: request.parallelism ?? 1,
      paused: request.paused ?? false
    };
    await this.http.request({
      method: "POST",
      path: ["v2", "queues"],
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body),
      parseResponseAsJson: false
    });
  }
  /**
   * Get the queue details
   */
  async get() {
    if (!this.queueName) {
      throw new Error("Please provide a queue name to the Queue constructor");
    }
    return await this.http.request({
      method: "GET",
      path: ["v2", "queues", this.queueName]
    });
  }
  /**
   * List queues
   */
  async list() {
    return await this.http.request({
      method: "GET",
      path: ["v2", "queues"]
    });
  }
  /**
   * Delete the queue
   */
  async delete() {
    if (!this.queueName) {
      throw new Error("Please provide a queue name to the Queue constructor");
    }
    await this.http.request({
      method: "DELETE",
      path: ["v2", "queues", this.queueName],
      parseResponseAsJson: false
    });
  }
  /**
   * Enqueue a message to a queue.
   */
  async enqueue(request) {
    if (!this.queueName) {
      throw new Error("Please provide a queue name to the Queue constructor");
    }
    const headers = processHeaders(request);
    const destination = getRequestPath(request);
    const response = await this.http.request({
      path: ["v2", "enqueue", this.queueName, destination],
      body: request.body,
      headers,
      method: "POST"
    });
    return response;
  }
  /**
   * Enqueue a message to a queue, serializing the body to JSON.
   */
  async enqueueJSON(request) {
    const headers = prefixHeaders(new Headers(request.headers));
    headers.set("Content-Type", "application/json");
    appendLLMOptionsIfNeeded(request, headers);
    const response = await this.enqueue({
      ...request,
      body: JSON.stringify(request.body),
      headers
    });
    return response;
  }
  /**
   * Pauses the queue.
   *
   * A paused queue will not deliver messages until
   * it is resumed.
   */
  async pause() {
    if (!this.queueName) {
      throw new Error("Please provide a queue name to the Queue constructor");
    }
    await this.http.request({
      method: "POST",
      path: ["v2", "queues", this.queueName, "pause"],
      parseResponseAsJson: false
    });
  }
  /**
   * Resumes the queue.
   */
  async resume() {
    if (!this.queueName) {
      throw new Error("Please provide a queue name to the Queue constructor");
    }
    await this.http.request({
      method: "POST",
      path: ["v2", "queues", this.queueName, "resume"],
      parseResponseAsJson: false
    });
  }
};

// src/client/schedules.ts
var Schedules = class {
  http;
  constructor(http) {
    this.http = http;
  }
  /**
   * Create a schedule
   */
  async create(request) {
    const headers = prefixHeaders(new Headers(request.headers));
    if (!headers.has("Content-Type")) {
      headers.set("Content-Type", "application/json");
    }
    headers.set("Upstash-Cron", request.cron);
    if (request.method !== void 0) {
      headers.set("Upstash-Method", request.method);
    }
    if (request.delay !== void 0) {
      headers.set("Upstash-Delay", `${request.delay.toFixed(0)}s`);
    }
    if (request.retries !== void 0) {
      headers.set("Upstash-Retries", request.retries.toFixed(0));
    }
    if (request.callback !== void 0) {
      headers.set("Upstash-Callback", request.callback);
    }
    if (request.failureCallback !== void 0) {
      headers.set("Upstash-Failure-Callback", request.failureCallback);
    }
    if (request.timeout !== void 0) {
      headers.set("Upstash-Timeout", `${request.timeout}s`);
    }
    return await this.http.request({
      method: "POST",
      headers,
      path: ["v2", "schedules", request.destination],
      body: request.body
    });
  }
  /**
   * Get a schedule
   */
  async get(scheduleId) {
    return await this.http.request({
      method: "GET",
      path: ["v2", "schedules", scheduleId]
    });
  }
  /**
   * List your schedules
   */
  async list() {
    return await this.http.request({
      method: "GET",
      path: ["v2", "schedules"]
    });
  }
  /**
   * Delete a schedule
   */
  async delete(scheduleId) {
    return await this.http.request({
      method: "DELETE",
      path: ["v2", "schedules", scheduleId],
      parseResponseAsJson: false
    });
  }
  /**
   * Pauses the schedule.
   *
   * A paused schedule will not deliver messages until
   * it is resumed.
   */
  async pause({ schedule }) {
    await this.http.request({
      method: "PATCH",
      path: ["v2", "schedules", schedule, "pause"],
      parseResponseAsJson: false
    });
  }
  /**
   * Resumes the schedule.
   */
  async resume({ schedule }) {
    await this.http.request({
      method: "PATCH",
      path: ["v2", "schedules", schedule, "resume"],
      parseResponseAsJson: false
    });
  }
};

// src/client/url-groups.ts
var UrlGroups = class {
  http;
  constructor(http) {
    this.http = http;
  }
  /**
   * Create a new url group with the given name and endpoints
   */
  async addEndpoints(request) {
    await this.http.request({
      method: "POST",
      path: ["v2", "topics", request.name, "endpoints"],
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ endpoints: request.endpoints }),
      parseResponseAsJson: false
    });
  }
  /**
   * Remove endpoints from a url group.
   */
  async removeEndpoints(request) {
    await this.http.request({
      method: "DELETE",
      path: ["v2", "topics", request.name, "endpoints"],
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ endpoints: request.endpoints }),
      parseResponseAsJson: false
    });
  }
  /**
   * Get a list of all url groups.
   */
  async list() {
    return await this.http.request({
      method: "GET",
      path: ["v2", "topics"]
    });
  }
  /**
   * Get a single url group
   */
  async get(name) {
    return await this.http.request({
      method: "GET",
      path: ["v2", "topics", name]
    });
  }
  /**
   * Delete a url group
   */
  async delete(name) {
    return await this.http.request({
      method: "DELETE",
      path: ["v2", "topics", name],
      parseResponseAsJson: false
    });
  }
};

// src/client/client.ts
var Client = class {
  http;
  token;
  constructor(config) {
    this.http = new HttpClient({
      retry: config.retry,
      baseUrl: config.baseUrl ? config.baseUrl.replace(/\/$/, "") : "https://qstash.upstash.io",
      authorization: `Bearer ${config.token}`
    });
    this.token = config.token;
  }
  /**
   * Access the urlGroup API.
   *
   * Create, read, update or delete urlGroups.
   */
  get urlGroups() {
    return new UrlGroups(this.http);
  }
  /**
   * Deprecated. Use urlGroups instead.
   *
   * Access the topic API.
   *
   * Create, read, update or delete topics.
   */
  get topics() {
    return this.urlGroups;
  }
  /**
   * Access the dlq API.
   *
   * List or remove messages from the DLQ.
   */
  get dlq() {
    return new DLQ(this.http);
  }
  /**
   * Access the message API.
   *
   * Read or cancel messages.
   */
  get messages() {
    return new Messages(this.http);
  }
  /**
   * Access the schedule API.
   *
   * Create, read or delete schedules.
   */
  get schedules() {
    return new Schedules(this.http);
  }
  /**
   * Access the queue API.
   *
   * Create, read, update or delete queues.
   */
  queue(request) {
    return new Queue(this.http, request?.queueName);
  }
  /**
   * Access the Chat API
   *
   * Call the create or prompt methods
   */
  chat() {
    return new Chat(this.http, this.token);
  }
  async publish(request) {
    const headers = processHeaders(request);
    const response = await this.http.request({
      path: ["v2", "publish", getRequestPath(request)],
      body: request.body,
      headers,
      method: "POST"
    });
    return response;
  }
  /**
   * publishJSON is a utility wrapper around `publish` that automatically serializes the body
   * and sets the `Content-Type` header to `application/json`.
   */
  async publishJSON(request) {
    const headers = prefixHeaders(new Headers(request.headers));
    headers.set("Content-Type", "application/json");
    appendLLMOptionsIfNeeded(request, headers);
    const response = await this.publish({
      ...request,
      headers,
      body: JSON.stringify(request.body)
    });
    return response;
  }
  /**
   * Batch publish messages to QStash.
   */
  async batch(request) {
    const messages = [];
    for (const message of request) {
      const headers = processHeaders(message);
      const headerEntries = Object.fromEntries(headers.entries());
      messages.push({
        destination: getRequestPath(message),
        headers: headerEntries,
        body: message.body,
        ...message.queueName && { queue: message.queueName }
      });
    }
    const response = await this.http.request({
      path: ["v2", "batch"],
      body: JSON.stringify(messages),
      headers: {
        "Content-Type": "application/json"
      },
      method: "POST"
    });
    return response;
  }
  /**
   * Batch publish messages to QStash, serializing each body to JSON.
   */
  async batchJSON(request) {
    for (const message of request) {
      if ("body" in message) {
        message.body = JSON.stringify(message.body);
      }
      message.headers = new Headers(message.headers);
      appendLLMOptionsIfNeeded(message, message.headers);
      message.headers.set("Content-Type", "application/json");
    }
    const response = await this.batch(request);
    return response;
  }
  /**
   * Retrieve your logs.
   *
   * The logs endpoint is paginated and returns only 100 logs at a time.
   * If you want to receive more logs, you can use the cursor to paginate.
   *
   * The cursor is a unix timestamp with millisecond precision
   *
   * @example
   * ```ts
   * let cursor = Date.now()
   * const logs: Log[] = []
   * while (cursor > 0) {
   *   const res = await qstash.logs({ cursor })
   *   logs.push(...res.logs)
   *   cursor = res.cursor ?? 0
   * }
   * ```
   */
  async events(request) {
    const query = {};
    if (request?.cursor && request.cursor > 0) {
      query.cursor = request.cursor.toString();
    }
    for (const [key, value] of Object.entries(request?.filter ?? {})) {
      if (typeof value === "number" && value < 0) {
        continue;
      }
      if (key === "urlGroup") {
        query.topicName = value.toString();
      } else if (typeof value !== "undefined") {
        query[key] = value.toString();
      }
    }
    const responsePayload = await this.http.request({
      path: ["v2", "events"],
      method: "GET",
      query
    });
    return {
      cursor: responsePayload.cursor,
      events: responsePayload.events.map((event) => {
        return {
          ...event,
          urlGroup: event.topicName
        };
      })
    };
  }
};

// src/client/llm/providers.ts
var upstash = () => {
  return {
    owner: "upstash",
    baseUrl: "https://qstash.upstash.io/llm",
    token: ""
  };
};
var openai = ({
  token
}) => {
  return { token, owner: "openai", baseUrl: "https://api.openai.com" };
};
var custom = ({
  baseUrl,
  token
}) => {
  const trimmedBaseUrl = baseUrl.replace(/\/(v1\/)?chat\/completions$/, "");
  return {
    token,
    owner: "custom",
    baseUrl: trimmedBaseUrl
  };
};
export {
  Chat,
  Client,
  Messages,
  QstashChatRatelimitError,
  QstashDailyRatelimitError,
  QstashError,
  QstashRatelimitError,
  Receiver,
  Schedules,
  SignatureError,
  UrlGroups,
  custom,
  openai,
  upstash
};
