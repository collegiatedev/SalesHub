"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }// src/receiver.ts
var _jose = require('jose'); var jose = _interopRequireWildcard(_jose);
var _cryptojs = require('crypto-js'); var _cryptojs2 = _interopRequireDefault(_cryptojs);
var SignatureError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "SignatureError";
  }
};
var Receiver = class {
  
  
  constructor(config) {
    this.currentSigningKey = config.currentSigningKey;
    this.nextSigningKey = config.nextSigningKey;
  }
  /**
   * Verify the signature of a request.
   *
   * Tries to verify the signature with the current signing key.
   * If that fails, maybe because you have rotated the keys recently, it will
   * try to verify the signature with the next signing key.
   *
   * If that fails, the signature is invalid and a `SignatureError` is thrown.
   */
  async verify(request) {
    const isValid = await this.verifyWithKey(this.currentSigningKey, request);
    if (isValid) {
      return true;
    }
    return this.verifyWithKey(this.nextSigningKey, request);
  }
  /**
   * Verify signature with a specific signing key
   */
  async verifyWithKey(key, request) {
    const jwt = await jose.jwtVerify(request.signature, new TextEncoder().encode(key), {
      issuer: "Upstash",
      clockTolerance: request.clockTolerance
    }).catch((error) => {
      throw new SignatureError(error.message);
    });
    const p = jwt.payload;
    if (request.url !== void 0 && p.sub !== request.url) {
      throw new SignatureError(`invalid subject: ${p.sub}, want: ${request.url}`);
    }
    const bodyHash = _cryptojs2.default.SHA256(request.body).toString(_cryptojs2.default.enc.Base64url);
    const padding = new RegExp(/=+$/);
    if (p.body.replace(padding, "") !== bodyHash.replace(padding, "")) {
      throw new SignatureError(`body hash does not match, want: ${p.body}, got: ${bodyHash}`);
    }
    return true;
  }
};




exports.SignatureError = SignatureError; exports.Receiver = Receiver;
